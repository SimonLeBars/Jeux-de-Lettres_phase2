package Game.Board;

import Game.Gameplay.Player;
import Game.Square.BonusSquare;
import Game.Square.ClearGridSquare;
import Game.Square.FundoxSquare;
import Game.Square.NormalSquare;
import Game.Tools.Direction;
import Game.Tools.Index2D;

import java.io.Serializable;
import java.util.ArrayList;

/**
 * Grid used to play Fundox.
 */
public class FundoxBoard extends Board implements Serializable {
    /**
     * Width and height of the board.
     */
    private static final int BOARD_SIZE = 13;

    /**
     * Minimum number of letters that needs to be placed by the player.
     */
    private static final int MIN_LETTER_PLACED_COUNT = 2;
    /**
     * The array containing the squares (cases) of the board.
     */
    protected final FundoxSquare[][] squares;

    /**
     * Constructor placing the bonus squares on the board.
     */
    public FundoxBoard() {
        this.squares = new FundoxSquare[BOARD_SIZE()][BOARD_SIZE()];
        this.isEmpty = true;
        for (int i = 0; i < BOARD_SIZE(); i++) {
            for (int j = 0; j < BOARD_SIZE(); j++) {
                if (i == BOARD_SIZE() / 2 && j == BOARD_SIZE() / 2) {
                    this.squares[i][j] = new NormalSquare();
                } else if ((i == 0 || i == BOARD_SIZE() / 2 || i == BOARD_SIZE() - 1) && (j == 0 || j == BOARD_SIZE() / 2 || j == BOARD_SIZE() - 1)) {
                    this.squares[i][j] = new ClearGridSquare();
                } else if (i == Math.abs(BOARD_SIZE() / 2 - j) || BOARD_SIZE() - 1 - i == Math.abs(BOARD_SIZE() / 2 - j)) {
                    this.squares[i][j] = new BonusSquare();
                } else {
                    this.squares[i][j] = new NormalSquare();
                }
            }
        }
    }

    /**
     * Getter of the board size attribute.
     *
     * @return Width/Height of the board.
     */
    @Override
    protected int BOARD_SIZE() {
        return BOARD_SIZE;
    }

    /**
     * Getter of the minimum amount of letters that needs to be placed by the player.
     *
     * @return Minimum amount.
     */
    @Override
	public int MIN_LETTER_PLACED_COUNT() {
        return MIN_LETTER_PLACED_COUNT;
    }

    /**
     * Returns the square (case) at [{@code line}][{@code column}]
     *
     * @param line   Line index of the square.
     * @param column Column index of the square.
     * @return Square indicated by the parameters.
     * @throws IllegalArgumentException If the indicated square is outside the board.
     */
    public FundoxSquare getSquare(int line, int column) throws IllegalArgumentException {
        if (line < 0
                || line > BOARD_SIZE()
                || column < 0
                || column > BOARD_SIZE()) {
            throw new IllegalArgumentException("Trying to access square outside the board.");
        }
        return this.squares[line][column];
    }

    /**
     * Counts the points scored by playing the word crossing the square [{@code firstSquareLine}][{@code firstSquareColumn}]
     * following the direction {@code direction} and the words generated by playing tiles in {@code placedTiles}
     * add them to the player {@code player}.
     *
     * @param firstSquareLine   Line index of the letter to start counting points from.
     * @param firstSquareColumn Column index of the letter to start counting points from.
     * @param direction         Direction of the placed word.
     * @param placedTiles       List of positions where the player has placed tile in the current turn.
     * @param player            Player to give the points to.
     * @throws IllegalArgumentException If a square outside the grid is tried to be accessed.
     */
    @Override
	public void countPoints(int firstSquareLine, int firstSquareColumn, Direction direction, ArrayList<Index2D> placedTiles, Player player) throws IllegalArgumentException {
        countWordPoints(firstSquareLine, firstSquareColumn, direction, player);
        for (Index2D placedTile : placedTiles) {
            countWordPoints(placedTile.LINE, placedTile.COLUMN, direction.getOpposite(), player);
        }
        clearGridIfNecessary(placedTiles, player);
    }

    /**
     * Counts the points scored by playing the word crossing the square [{@code firstSquareLine}][{@code firstSquareColumn}]
     * following the direction {@code direction}.
     * Sets the ownership of the tiles to the player {@code player} and updates the points of the player taking ownership and of the players losing ownership.
     *
     * @param squareLine   Line index of the letter to start counting points from.
     * @param squareColumn Column index of the letter to start counting points from.
     * @param direction    Direction of the word.
     * @param player       Player that placed the word.
     * @throws IllegalArgumentException If a square outside the grid is tried to be accessed.
     */
    private void countWordPoints(int squareLine, int squareColumn, Direction direction, Player player) throws IllegalArgumentException {
        assertSquareIsNotEmpty(squareLine, squareColumn);

        int firstLetterIndex = getFirstLetterIndexOfWordAt(squareLine, squareColumn, direction);

        int lastLetterIndex = getLastLetterIndexOfWordAt(squareLine, squareColumn, direction);

        int wordLength = lastLetterIndex - firstLetterIndex + 1;

        for (int k = 0; k < wordLength; k++) {
            if (direction.isHorizontal()) {
                getOwnership(player, this.getSquare(squareLine, firstLetterIndex + k));
            } else {
                getOwnership(player, this.getSquare(firstLetterIndex + k, squareColumn));
            }
        }
    }

    /**
     * Set the ownership of the {@code square} to the {@code player} and updates the points accordingly.
     *
     * @param player Player taking ownership.
     * @param square Square getting updated.
     */
    private void getOwnership(Player player, FundoxSquare square) {
        if (square.isOwned()) {
            square.getOwner().addScore(-1);
        } else if (!square.isBonusUsed()) {
            player.increaseBonusCount();
            square.setBonusOwner(player);
            square.markBonusAsUsed();
        }
        square.setOwner(player);
        player.addScore(1);
    }

    /**
     * Clears the grid and computing scores if one of the placed tiles is on a grid clearing square.
     *
     * @param placedTiles List of positions of the squares where a tile has been placed.
     * @throws IllegalArgumentException If a square outside the grid is tried to be accessed.
     */
    private void clearGridIfNecessary(ArrayList<Index2D> placedTiles, Player player) throws IllegalArgumentException {
        for (Index2D placedTile : placedTiles) {
            if (this.getSquare(placedTile.LINE, placedTile.COLUMN).gridShouldBeCleared()) {
                player.addScore(player.getBonusCount());
                clearGrid();
                break;
            }
        }
    }

    /**
     * Clears the grid by resetting squares and updating player's bonus count to zero.
     */
    private void clearGrid() {
        FundoxSquare square;
        for (int i = 0; i < BOARD_SIZE(); i++) {
            for (int j = 0; j < BOARD_SIZE(); j++) {
                square = this.getSquare(i, j);
                if (square.isOwned()) {
                    if (square.isBonusOwned()) {
                        square.getBonusOwner().setBonusCount(0);
                    }
                    square.reset();
                }
            }
        }
        this.isEmpty = true;
    }

    /**
     * Returns a string representation of the board. Displays the grid with indexes.
     *
     * @return String representation.
     */
    @Override
    public String toString() {
        StringBuilder str = new StringBuilder();
        str.append("i\\j\t");
        for (int j = 0; j < BOARD_SIZE(); j++) {
            str.append(Integer.toString(j).length() > 1 ? " " : "  ").append(j).append(" ");
        }
        for (int i = 0; i < BOARD_SIZE(); i++) {
            str.append("\n");
            str.append(i).append("\t");
            for (int j = 0; j < BOARD_SIZE(); j++) {
                str.append(this.squares[i][j].toString());
            }
        }
        return str.toString();
    }

}
